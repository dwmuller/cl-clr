Some of these items are more on the order of "wish" or "whacky idea to
investigate" than "to do".

- In GET-TYPE-SYMBOL, check efficiency. Perhaps use binding flags to
  limit to members of interest -- although ultimately all public
  member of interest? Handle nested types if they're included in the
  member list. (I doubt they are.)

- UNUSE-NAMESPACE does not attempt to remove type or member symbols
  from the target package. Member symbols would be difficult to do,
  but types would easily be possible. Should it do so? This would be
  more analogous to UNUSE-PACKAGE.

- Separate 'importing' from 'binding'.

- Add event support.

- Allow overriding of the package name prefix for namespace packages.

- Allow the addition of a namespace prefix on assembly contents when
  loading (or binding?) an assembly.

- Allow specifying how CLR names are translated to symbol names:
  :upcase, :downcase, :preserve, :invert, and :lisp to attempt
  conversion to Lisp-like naming conventions. Default to :preserve.

- Integrate as much as possible into RDNZL, if Edi agrees. Need to
  work out with him what aspects are incompatible with current RDNZL
  semantics and syntax, and to what extent this is an issue. (How many
  RDNZL users are there? How open to change are they? Does Edi even
  think the ideas in CL-CLR worthwhile, or does he see flaws that I've
  missed so far?)

- Enhance SLIME's symbol completion logic. Possible algorithm:
  - Make elisp code find symbol begin across escapes
  - Close any open multi-escape.
  - Read as an uninterned symbol to find out what the reader makes of it.
  - Use the resulting symbol's name directly to find candidates.

- Or: Abandon the reader. Depends on how valuable the incremental
  loading is. Have to get some stats on how heavy a load the extra
  packages and symbols impose on an image.

- Automatic caching of candidate member info sets, in a member or
  type symbol property.  See System.Reflection.Binder.BindToMethod
  and BindToField for some ideas on why this would be useful. (For
  properties, perhaps need to use the set/get method names?)

- Allow strings to be provided where member or type objects are
  now required. Of course, the above-mentioned caching of member
  info won't happen in such cases.

- A custom binder could provide a more elegant and correct solution to
  the LispWorks single/double float problem, sacrificing precision
  only when necessary to find a signature match.

- Define member symbols as macros rather than functions. Expand them
  to unique symbols defined such that they can still serve as member
  symbols, but also represent a unique calling site that
  self-optimizes the member lookup at runtime.


Testing TODO:

- Test performance, compare to RDNZL.

- Test image creation and loading.
