Some of these items are more on the order of "wish" or "whacky idea to
investigate" than "to do".

- INVOKE-MEMBER has one, possibly serious, problem. It uses
  System.Type.InvokeMember, which is a great shortcut compared to
  looking up MemberInfo objects. Unfortunately, the declared return
  type is Object, so that's the type that resulting containers will
  have. INVOKE-MEMBER casts to the dynamically-determined type.

- The item above raises an interesting point. RDNZL follows Pinto's
  approach in keeping the 'declared' or 'apparent' type with an object
  reference, and using that as the basis for member lookups. This
  follows the model of statically-typed languages like C#. I wonder if
  this is worthwhile. I think the situations where a fully dynamic
  approach causes problems are rare, and can be addressed through a
  separate, explicit mechanism. (E.g. a TREAT-AS wrapper.) If this
  were abandoned, the implementation could be much more efficient. In
  fact, the DotNetContainer and DotNetReference classes could go away
  entirely, using (GC-locked) CLR object references directly!

  I have tweaked CL-CLR so that it consistently casts returned
  containers to the run-time type, in order to experiment with this.

- In GET-TYPE-SYMBOL, check efficiency. Perhaps use binding flags to
  limit to members of interest -- although ultimately all public
  members are of interest? 

- Add event support.

- Allow overriding of the package name prefix for namespace packages.

- Allow the addition of a namespace prefix on assembly contents when
  loading (or binding?) an assembly. Track loaded assemblies?

- Allow specifying how CLR names are translated to symbol names:
  :upcase, :downcase, :preserve, :invert, and :lisp to attempt
  conversion to Lisp-like naming conventions. Default to :preserve,
  because it's the least likely to collide with Lisp names.

- Find out what, if anything, Edi would like to integrate into RDNZL
  from this. Need to work out with him what aspects are incompatible
  with current RDNZL semantics and syntax, and to what extent this is
  an issue. (How many RDNZL users are there? How open to change are
  they? Does Edi even think the ideas in CL-CLR worthwhile, or does he
  see flaws that I've missed so far?)

- Enhance SLIME's symbol completion logic. Possible algorithm:
  - Make elisp code find symbol begin across escapes
  - Close any open multi-escape.
  - Read as an uninterned symbol to find out what the reader makes of it.
  - Use the resulting symbol's name directly to find candidates.

- Automatic run-time incremental caching of candidate member info
  sets, in a member or type symbol property.  See
  System.Reflection.Binder.BindToMethod and BindToField for some ideas
  on why this would be useful. (For properties, perhaps need to use
  the set/get method names?)

- Allow strings to be provided where member or type objects are now
  required? Of course, the above-mentioned caching of member info
  won't happen in such cases. I'm not terribly interested in this,
  actually, but maybe others see a need for it.

- A custom Binder could provide a more elegant and correct solution to
  the LispWorks single/double float problem, sacrificing precision
  only when necessary to find a signature match.

- Define member symbols as macros rather than functions. Expansion
  could include a unique symbol defined such that it could represent a
  unique calling site that self-optimizes the member lookup at
  runtime. Unfortunately, and perhaps terminally so, this would
  preclude the use of member symbols with functions like APPLY or MAP.


Testing TODO:

- Test performance, compare to RDNZL.

- Test image creation and loading.
